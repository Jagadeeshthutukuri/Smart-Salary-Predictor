# -*- coding: utf-8 -*-
"""IBM salary Prediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11rmktlbsNBxIqZQBltcfrW1VcFcA7NPO
"""

import pandas as pd

data=pd.read_csv(r"/content/adult 3.csv")
data

data.head(10)

data.tail(3)

data.shape

#null values
data.isna().sum() #mean mdeian mode arbitrary

print(data.workclass.value_counts())

data.workclass.replace({'?':'Others'},inplace=True)
print(data['workclass'].value_counts())

print(data['occupation'].value_counts())

data.occupation.replace({'?':'Others'},inplace=True)
print(data['occupation'].value_counts())

data=data[data['workclass']!='Without-pay']
data=data[data['workclass']!='Never-worked']
print(data['workclass'].value_counts())

print(data.relationship.value_counts())

print(data.gender.value_counts())

data.shape

#outlier detection
import matplotlib.pyplot as plt   #visualization
plt.boxplot(data['age'])
plt.show()

data=data[(data['age']<=75)&(data['age']>=17)]

plt.boxplot(data['age'])
plt.show()

data.shape

plt.boxplot(data['capital-gain'])
plt.show()

plt.boxplot(data['age'])
plt.show()

plt.boxplot(data['capital-gain'])
plt.show()

plt.boxplot(data['educational-num'])
plt.show()

data=data[(data['educational-num']<=16)&(data['educational-num']>=5)]

plt.boxplot(data['educational-num'])
plt.show()

plt.boxplot(data['hours-per-week'])
plt.show()

data.shape

data=data.drop(columns=['education']) #redundant features removal

data

from sklearn.preprocessing import LabelEncoder   #import libarary
encoder=LabelEncoder()                       #create object
data['workclass']=encoder.fit_transform(data['workclass']) #7 categories   0,1, 2, 3, 4, 5, 6,
data['marital-status']=encoder.fit_transform(data['marital-status'])   #3 categories 0, 1, 2
data['occupation']=encoder.fit_transform(data['occupation'])
data['relationship']=encoder.fit_transform(data['relationship'])      #5 categories  0, 1, 2, 3, 4
data['race']=encoder.fit_transform(data['race'])
data['gender']=encoder.fit_transform(data['gender'])    #2 catogories     0, 1
data['native-country']=encoder.fit_transform(data['native-country'])

data

x=data.drop(columns=['income'])
y=data['income']
x

from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.impute import SimpleImputer

# Drop rows with NaN in 'income' from both x and y
data_cleaned = data.dropna(subset=['income'])
x_cleaned = data_cleaned.drop(columns=['income'])
y_cleaned = data_cleaned['income']

X_train, X_test, y_train, y_test = train_test_split(x_cleaned, y_cleaned, test_size=0.2, random_state=42)

models = {
    "LogisticRegression": LogisticRegression(),
    "RandomForest": RandomForestClassifier(),
    "KNN": KNeighborsClassifier(),
    "SVM": SVC(),
    "GradientBoosting": GradientBoostingClassifier()
}

results = {}

for name, model in models.items():
    pipe = Pipeline([
        ('imputer', SimpleImputer(strategy='mean')), # Add imputer to handle NaNs in features
        ('scaler', StandardScaler()),
        ('model', model)
    ])

    pipe.fit(X_train, y_train)
    y_pred = pipe.predict(X_test)
    acc = accuracy_score(y_test, y_pred)
    results[name] = acc
    print(f"{name} Accuracy: {acc:.4f}")
    print(classification_report(y_test, y_pred))

import matplotlib.pyplot as plt
plt.bar(results.keys(), results.values(), color='skyblue')
plt.ylabel('Accuracy Score')
plt.title('Model Comparison')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

!ngrok config add-authtoken 302wjcN9H8c4q59gdr3VCLVQqWY_4EqTjcJ9nyPkpG7gdVL4f

!pip install streamlit pyngrok

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import numpy as np
# from sklearn.preprocessing import LabelEncoder, StandardScaler
# from sklearn.ensemble import RandomForestRegressor
# from sklearn.pipeline import Pipeline
# from sklearn.model_selection import train_test_split
# import io
# 
# # -------------------- Custom CSS -------------------- #
# st.markdown("""
# <style>
# @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap');
# 
# html, body, [class*="css"] {
#     font-family: 'Poppins', sans-serif;
# }
# 
# h1 {
#     color: #2F80ED;
# }
# 
# h2, h3 {
#     color: #1B1B1B;
# }
# 
# span.tagline {
#     font-size: 18px;
#     color: #555;
#     font-weight: 400;
# }
# 
# div.stButton > button:first-child {
#     background-color: #007BFF;
#     color: white;
#     font-weight: bold;
#     border-radius: 6px;
#     transition: all 0.3s ease-in-out;
# }
# 
# div.stButton > button:first-child:hover {
#     background-color: #0056b3;
#     transform: scale(1.05);
# }
# </style>
# """, unsafe_allow_html=True)
# 
# # -------------------- Data Preparation -------------------- #
# @st.cache_data
# def load_data():
#     df = pd.read_csv('/content/adult 3.csv')
#     df.replace({'?': 'Others'}, inplace=True)
#     df = df[(df['age'] >= 17) & (df['age'] <= 75)]
#     df = df[(df['educational-num'] >= 5) & (df['educational-num'] <= 16)]
#     df = df[~df['workclass'].isin(['Without-pay', 'Never-worked'])]
#     df.drop(columns=['education'], inplace=True)
# 
#     categorical_cols = ['workclass', 'marital-status', 'occupation', 'relationship', 'race', 'gender', 'native-country']
#     encoders = {}
#     for col in categorical_cols:
#         le = LabelEncoder()
#         df[col] = le.fit_transform(df[col])
#         encoders[col] = le
# 
#     df['experience'] = np.random.randint(0, 31, len(df))
#     y = (
#         df['age'] * 2000 +
#         df['educational-num'] * 7000 +
#         df['hours-per-week'] * 3000 +
#         df['experience'] * 4000 +
#         np.random.randint(15000, 90000, len(df))
#     )
#     x = df.drop(columns=['income'])
#     return x, y, encoders, list(x.columns)
# 
# # -------------------- Model Training -------------------- #
# x, y, encoders, feature_order = load_data()
# X_train, X_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)
# 
# pipe = Pipeline([
#     ('scaler', StandardScaler()),
#     ('model', RandomForestRegressor(n_estimators=50, max_depth=6, n_jobs=-1, random_state=42))
# ])
# pipe.fit(X_train, y_train)
# 
# # -------------------- App Title & Tagline -------------------- #
# st.title("üíº Smart Salary Predictor")
# st.markdown('<span class="tagline">Uncover your true earning potential powered by intelligent predictions.</span>', unsafe_allow_html=True)
# 
# # -------------------- Sidebar Inputs -------------------- #
# with st.sidebar:
#     st.header("üßæ Enter Employee Details")
#     age = st.number_input("Age", 17, 75, 30)
#     edu_num = st.slider("Education Level (num)", 5, 16, 10)
#     marital_status = st.selectbox("Marital Status", encoders['marital-status'].classes_)
#     hours_per_week = st.slider("Hours Per Week", 1, 99, 40)
#     country = st.selectbox("Native Country", encoders['native-country'].classes_)
#     gender = st.selectbox("Gender", encoders['gender'].classes_)
#     relationship = st.selectbox("Relationship", encoders['relationship'].classes_)
#     occupation = st.selectbox("Occupation", encoders['occupation'].classes_)
#     experience = st.slider("Years of Experience", 0, 30, 5)
# 
# # -------------------- Input Builder -------------------- #
# def build_input(exp_override=None):
#     row = {}
#     for col in feature_order:
#         if col == 'age':
#             row[col] = age
#         elif col == 'educational-num':
#             row[col] = edu_num
#         elif col == 'marital-status':
#             row[col] = encoders['marital-status'].transform([marital_status])[0]
#         elif col == 'hours-per-week':
#             row[col] = hours_per_week
#         elif col == 'native-country':
#             row[col] = encoders['native-country'].transform([country])[0]
#         elif col == 'gender':
#             row[col] = encoders['gender'].transform([gender])[0]
#         elif col == 'relationship':
#             row[col] = encoders['relationship'].transform([relationship])[0]
#         elif col == 'occupation':
#             row[col] = encoders['occupation'].transform([occupation])[0]
#         elif col == 'experience':
#             row[col] = exp_override if exp_override is not None else experience
#         else:
#             row[col] = x[col].mean()
#     return pd.DataFrame([row])
# 
# # -------------------- Tip Generator -------------------- #
# def salary_tip(salary):
#     if salary < 250000:
#         return "üìò Entry salary. Focus on certifications and upskilling."
#     elif salary < 350000:
#         return "üí° Great progress! Specialize in niche technologies."
#     elif salary < 500000:
#         return "üöÄ You're doing well. Think about promotions or switching roles."
#     else:
#         return "üåü Excellent! Consider mentoring and expanding your leadership."
# 
# # -------------------- Prediction Section -------------------- #
# st.markdown("## üîç Salary Insight")
# 
# if st.button("üéØ Predict Salary Now"):
#     input_df = build_input()
#     annual = pipe.predict(input_df)[0]
#     monthly = annual / 12
# 
#     st.markdown(f"<h4 style='color:#27AE60;'>üóìÔ∏è Annual Salary: ‚Çπ{annual:,.2f}</h4>", unsafe_allow_html=True)
#     st.markdown(f"<h4 style='color:#2D9CDB;'>üìÖ Monthly Salary: ‚Çπ{monthly:,.2f}</h4>", unsafe_allow_html=True)
#     st.info(salary_tip(annual))
#     st.balloons()
# 
#     # Show input summary
#     user_input_df = pd.DataFrame({
#         "Age": [age],
#         "Education Level": [edu_num],
#         "Experience": [experience],
#         "Hours per Week": [hours_per_week],
#         "Country": [country],
#         "Gender": [gender],
#         "Relationship": [relationship],
#         "Occupation": [occupation]
#     })
#     st.markdown("### üìã Employee Input Summary")
#     st.dataframe(user_input_df)
# 
#     # -------------------- Chart -------------------- #
#     exp_range = list(range(1, 31))
#     exp_inputs = pd.concat([build_input(exp) for exp in exp_range])
#     exp_preds = pipe.predict(exp_inputs)
# 
#     chart_data = pd.DataFrame({
#         'Years of Experience': exp_range,
#         'Predicted Salary': exp_preds
#     })
# 
#     st.markdown("### üìà Experience vs Predicted Salary")
#     st.line_chart(chart_data.set_index('Years of Experience'))
# 
#     # -------------------- CSV Export -------------------- #
#     result_df = pd.DataFrame({
#         'Age': [age],
#         'Education Level': [edu_num],
#         'Experience': [experience],
#         'Hours/Week': [hours_per_week],
#         'Country': [country],
#         'Gender': [gender],
#         'Occupation': [occupation],
#         'Predicted Annual Salary': [round(annual, 2)],
#         'Predicted Monthly Salary': [round(monthly, 2)]
#     })
# 
#     buffer = io.StringIO()
#     result_df.to_csv(buffer, index=False)
#     st.download_button("üìÅ Download Result as CSV", data=buffer.getvalue(), file_name="salary_prediction.csv", mime="text/csv")
# 
# # -------------------- Batch Prediction -------------------- #
# st.markdown("---")
# st.markdown("## üìÇ Batch Salary Prediction (Upload CSV)")
# 
# uploaded_file = st.file_uploader("Upload a CSV with employee records", type=["csv"])
# 
# if uploaded_file is not None:
#     batch_df = pd.read_csv(uploaded_file)
#     try:
#         # Encode categorical columns
#         for col in encoders:
#             if col in batch_df.columns:
#                 batch_df[col] = encoders[col].transform(batch_df[col])
# 
#         # Ensure all features present
#         for col in feature_order:
#             if col not in batch_df.columns:
#                 batch_df[col] = x[col].mean()
# 
#         predictions = pipe.predict(batch_df[feature_order])
#         batch_df['Predicted Annual Salary'] = predictions
#         batch_df['Predicted Monthly Salary'] = predictions / 12
# 
#         st.success("‚úÖ Batch predictions completed!")
#         st.dataframe(batch_df[['age', 'educational-num', 'experience', 'hours-per-week', 'Predicted Annual Salary', 'Predicted Monthly Salary']])
# 
#         out_buffer = io.StringIO()
#         batch_df.to_csv(out_buffer, index=False)
#         st.download_button("üì• Download Batch Prediction CSV", data=out_buffer.getvalue(), file_name="batch_salary_prediction.csv", mime="text/csv")
# 
#     except Exception as e:
#         st.error(f"‚ùå Error processing file: {e}")
#

from pyngrok import ngrok
import time

ngrok.kill()
!streamlit run app.py &>/content/log.txt &
time.sleep(5)
public_url = ngrok.connect(addr="8501", proto="http")
print(f"Public URL: {public_url}")